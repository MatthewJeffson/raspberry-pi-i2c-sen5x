/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * I2C-Generator: 0.2.0
 * Yaml Version: 0.5.1
 * Template Version: 0.7.0-8-gbdfd7a4
 */
/*
 * Copyright (c) 2021, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef SEN55_I2C_H
#define SEN55_I2C_H

#ifdef __cplusplus
extern "C" {
#endif

#include "sensirion_config.h"

/**
 * sen55_start_measurement() - Starts a continuous measurement.
 *
 * @note After starting the measurement, it takes some time (~1s) until the
 * first measurement results are available. You could poll with the command
 * 0x0202 \"Read Data Ready\" to check when the results are ready to read.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_start_measurement(void);

/**
 * sen55_stop_measurement() - Stops the measurement and returns to idle mode.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_stop_measurement(void);

/**
 * sen55_read_data_ready() - This command can be used to check if new
 * measurement results are ready to read. The data ready flag is automatically
 * reset after reading the measurement values with the 0x03.. \"Read Measured
 * Values\" commands.
 *
 * @param padding Padding byte, always 0x00.
 *
 * @param data_ready True (0x01) if data is ready, False (0x00) if not.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_read_data_ready(bool* data_ready);

/**
 * sen55_read_measured_pm_values_float() - Returns the measured particulate
 * matter values as floating point numbers. The command 0x0202 \"Read Data
 * Ready\" can be used to check if new data is available since the last read
 * operation. If no new data is available, the previous values will be returned
 * again. If no data is available at all (e.g. measurement not running for at
 * least one Second), NaN is returned for all values.
 *
 * @param mass_concentration_pm1p0 Value is returned in the unit µg/m³.
 *
 * @param mass_concentration_pm2p5 Value is returned in the unit µg/m³.
 *
 * @param mass_concentration_pm4p0 Value is returned in the unit µg/m³.
 *
 * @param mass_concentration_pm10p0 Value is returned in the unit µg/m³.
 *
 * @param number_concentration_pm0p5 Value is returned in the unit #/cm³.
 *
 * @param number_concentration_pm1p0 Value is returned in the unit #/cm³.
 *
 * @param number_concentration_pm2p5 Value is returned in the unit #/cm³.
 *
 * @param number_concentration_pm4p0 Value is returned in the unit #/cm³.
 *
 * @param number_concentration_pm10p0 Value is returned in the unit #/cm³.
 *
 * @param typical_particle_size Value is returned in the unit µm.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_read_measured_pm_values_float(
    float* mass_concentration_pm1p0, float* mass_concentration_pm2p5,
    float* mass_concentration_pm4p0, float* mass_concentration_pm10p0,
    float* number_concentration_pm0p5, float* number_concentration_pm1p0,
    float* number_concentration_pm2p5, float* number_concentration_pm4p0,
    float* number_concentration_pm10p0, float* typical_particle_size);

/**
 * sen55_read_measured_values() - Returns the measured values. The command
0x0202 \"Read Data Ready\" can be used to check if new data is available since
the last read operation. If no new data is available, the previous values will
be returned again. If no data is available at all (e.g. measurement not running
for at least one Second), all values will be at their upper limit (0xFFFF for
`uint16`, 0x7FFF for `int16`).
 *
 * @param mass_concentration_pm1p0 Value is scaled with factor 10: PM1.0 [µg/m³]
= value / 10

*Note: If this value is unknown, 0xFFFF is returned.*
 *
 * @param mass_concentration_pm2p5 Value is scaled with factor 10: PM2.5 [µg/m³]
= value / 10

*Note: If this value is unknown, 0xFFFF is returned.*
 *
 * @param mass_concentration_pm4p0 Value is scaled with factor 10: PM4.0 [µg/m³]
= value / 10

*Note: If this value is unknown, 0xFFFF is returned.*
 *
 * @param mass_concentration_pm10p0 Value is scaled with factor 10: PM10.0
[µg/m³] = value / 10

*Note: If this value is unknown, 0xFFFF is returned.*
 *
 * @param ambient_humidity Value is scaled with factor 100: RH [%] = value / 100

*Note: If this value is unknown, 0x7FFF is returned.*
 *
 * @param ambient_temperature Value is scaled with factor 200: T [°C] = value /
200

*Note: If this value is unknown, 0x7FFF is returned.*
 *
 * @param voc_index Value is scaled with factor 10: VOC Index = value / 10

*Note: If this value is unknown, 0x7FFF is returned.*

**Attention: This feature is not available yet, thus currently the
value 0x7FFF is returned.**
 *
 * @param nox_index Value is scaled with factor 10: NOx Index = value / 10

*Note: If this value is unknown, 0x7FFF is returned.*

**Attention: This feature is not available yet, thus currently the
value 0x7FFF is returned.**
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_read_measured_values(uint16_t* mass_concentration_pm1p0,
                                   uint16_t* mass_concentration_pm2p5,
                                   uint16_t* mass_concentration_pm4p0,
                                   uint16_t* mass_concentration_pm10p0,
                                   int16_t* ambient_humidity,
                                   int16_t* ambient_temperature,
                                   int16_t* voc_index, int16_t* nox_index);

/**
 * sen55_read_measured_raw_values() - Returns the measured raw values. The
command 0x0202 \"Read Data Ready\" can be used to check if new data is available
since the last read operation. If no new data is available, the previous values
will be returned again. If no data is available at all (e.g. measurement not
running for at least one Second), all values will be at their upper limit
(0xFFFF for `uint16`, 0x7FFF for `int16`).
 *
 * @param raw_humidity Value is scaled with factor 100: RH [%] = value / 100

*Note: If this value is unknown, 0x7FFF is returned.*
 *
 * @param raw_temperature Value is scaled with factor 200: T [°C] = value / 200

*Note: If this value is unknown, 0x7FFF is returned.*
 *
 * @param raw_voc Raw measured VOC ticks without scale factor.

*Note: If this value is unknown, 0xFFFF is returned.*

**Attention: Currently this value is not humidity compensated. The
compensation will be implemented in a later firmware release.**
 *
 * @param raw_nox Raw measured NOx ticks without scale factor.

*Note: If this value is unknown, 0xFFFF is returned.*

**Attention: Currently this value is not humidity compensated. The
compensation will be implemented in a later firmware release.**
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_read_measured_raw_values(int16_t* raw_humidity,
                                       int16_t* raw_temperature,
                                       uint16_t* raw_voc, uint16_t* raw_nox);

/**
 * sen55_start_fan_cleaning() - Starts the fan cleaning manually. During the
next few Seconds, no new measurement results will be available (old values will
be returned, and the \"data ready\"-flag will not be set).

**Attention: This feature is not implemented yet, it is just a dummy
command with no effect.**
 *
 * @note The cleaning will be started only if the device is in measure mode. In
idle mode, this command does nothing.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_start_fan_cleaning(void);

/**
 * sen55_set_fan_auto_cleaning_interval() - Sets the fan auto cleaning interval
 * for the device.
 *
 * @note This configuration is volatile, i.e. it will be reverted to the default
 * value after a device reset.
 *
 * @param interval Fan auto cleaning interval [s]. Set to zero to disable auto
 * cleaning.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_set_fan_auto_cleaning_interval(uint32_t interval);

/**
 * sen55_get_fan_auto_cleaning_interval() - Gets the fan auto cleaning interval
 * from the device.
 *
 * @param interval Fan auto cleaning interval [s]. Zero means auto cleaning is
 * disabled.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_get_fan_auto_cleaning_interval(uint32_t* interval);

/**
 * sen55_get_product_name() - Gets the product name from the device.
 *
 * @param product_name Null-terminated ASCII string containing the product name.
 * Up to 32 characters can be read from the device.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_get_product_name(unsigned char* product_name,
                               uint8_t product_name_size);

/**
 * sen55_get_serial_number() - Gets the serial number from the device.
 *
 * @param serial_number Null-terminated ASCII string containing the serial
 * number. Up to 32 characters can be read from the device.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_get_serial_number(unsigned char* serial_number,
                                uint8_t serial_number_size);

/**
 * sen55_get_version() - Gets the version information for the hardware, firmware
 * and communication protocol.
 *
 * @param firmware_major Firmware major version number.
 *
 * @param firmware_minor Firmware minor version number.
 *
 * @param firmware_debug Firmware debug state. If the debug state is set, the
 * firmware is in development.
 *
 * @param hardware_major Hardware major version number.
 *
 * @param hardware_minor Hardware minor version number.
 *
 * @param protocol_major Protocol major version number.
 *
 * @param protocol_minor Protocol minor version number.
 *
 * @param padding Padding byte, ignore this.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_get_version(uint8_t* firmware_major, uint8_t* firmware_minor,
                          bool* firmware_debug, uint8_t* hardware_major,
                          uint8_t* hardware_minor, uint8_t* protocol_major,
                          uint8_t* protocol_minor);

/**
 * sen55_read_device_status() - Reads the current device status register.
 *
 * @param device_status Device status (32 flags as an integer value). For
 * details, please refer to the device status flags documentation.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_read_device_status(uint32_t* device_status);

/**
 * sen55_read_and_clear_device_status() - Reads the current device status
 * register (like command 0xD206 \"Read Device Status\") and afterwards clears
 * all flags.
 *
 * @param device_status Device status (32 flags as an integer value). For
 * details, please refer to the device status flags documentation.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_read_and_clear_device_status(uint32_t* device_status);

/**
 * sen55_device_reset() - Executes a reset on the device. This has the same
 * effect as a power cycle.
 *
 * @return 0 on success, an error code otherwise
 */
int16_t sen55_device_reset(void);

#ifdef __cplusplus
}
#endif

#endif /* SEN55_I2C_H */
